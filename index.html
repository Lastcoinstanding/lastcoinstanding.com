<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0"/>
<title>The Money Trees — Last Coin Standing</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400&family=Inter:wght@500;600;700&display=swap');

:root {
  --btc-orange: #f7931a;
  --btc-gold: #ffb840;
  --btc-amber: #e8a020;
  --btc-bark: #5a4030;
  --btc-bark-light: #7a6050;
  --btc-bg: #0f0d0a;
  
  --fiat-steel: #6a7580;
  --fiat-slate: #4a5560;
  --fiat-rust: #7a5555;
  --fiat-cold: #2a3038;
  --fiat-bark: #454550;
  --fiat-bg: #0a0c0f;
  
  --font-display: 'Cormorant Garamond', Georgia, serif;
  --font-ui: 'Inter', -apple-system, sans-serif;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

html {
  scroll-behavior: smooth;
}

body {
  min-height: 100vh;
  font-family: var(--font-display);
  color: #ddd;
  overflow-x: hidden;
  transition: background 0.5s ease;
}

body.btc-view {
  background: linear-gradient(180deg, #100d08 0%, #1a1510 30%, #1a1510 70%, #100d08 100%);
}

body.fiat-view {
  background: linear-gradient(180deg, #08090c 0%, #12151a 30%, #12151a 70%, #08090c 100%);
}

/* ─── HEADER ─── */
header {
  text-align: center;
  padding: 24px 16px 8px;
  position: sticky;
  top: 0;
  z-index: 100;
  background: inherit;
}

body.btc-view header {
  background: linear-gradient(180deg, #100d08 0%, rgba(16,13,8,0.95) 100%);
}

body.fiat-view header {
  background: linear-gradient(180deg, #08090c 0%, rgba(8,9,12,0.95) 100%);
}

header h1 {
  font-weight: 500;
  font-size: clamp(1.2rem, 5vw, 2.1rem);
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: #f0e8e0;
  margin-bottom: 4px;
}

header p {
  font-style: italic;
  font-weight: 400;
  color: #908880;
  font-size: clamp(0.85rem, 2.5vw, 1.05rem);
}

/* ─── TOGGLE SWITCH ─── */
.toggle-container {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 14px;
  padding: 14px 16px;
  position: sticky;
  top: 60px;
  z-index: 100;
}

body.btc-view .toggle-container {
  background: linear-gradient(180deg, rgba(16,13,8,0.95) 0%, rgba(16,13,8,0) 100%);
}

body.fiat-view .toggle-container {
  background: linear-gradient(180deg, rgba(8,9,12,0.95) 0%, rgba(8,9,12,0) 100%);
}

.toggle-label {
  font-family: var(--font-ui);
  font-size: clamp(0.85rem, 3vw, 0.95rem);
  font-weight: 600;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  cursor: pointer;
  padding: 10px 16px;
  border-radius: 6px;
  transition: all 0.3s ease;
  user-select: none;
}

.toggle-label.btc {
  color: var(--btc-orange);
  opacity: 0.5;
}

.toggle-label.fiat {
  color: var(--fiat-steel);
  opacity: 0.5;
}

.toggle-label.active {
  opacity: 1;
}

body.btc-view .toggle-label.btc {
  background: rgba(247, 147, 26, 0.18);
  box-shadow: 0 0 20px rgba(247, 147, 26, 0.25);
}

body.fiat-view .toggle-label.fiat {
  background: rgba(100, 115, 130, 0.22);
  box-shadow: 0 0 20px rgba(100, 115, 130, 0.18);
}

.toggle-switch {
  width: 56px;
  height: 28px;
  background: #1a1a1a;
  border-radius: 14px;
  position: relative;
  cursor: pointer;
  border: 2px solid #333;
  transition: all 0.3s ease;
  flex-shrink: 0;
}

.toggle-switch::after {
  content: '';
  position: absolute;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  top: 2px;
  transition: all 0.3s ease;
}

body.btc-view .toggle-switch {
  border-color: rgba(247, 147, 26, 0.5);
}

body.btc-view .toggle-switch::after {
  left: 3px;
  background: var(--btc-orange);
  box-shadow: 0 0 10px rgba(247, 147, 26, 0.6);
}

body.fiat-view .toggle-switch {
  border-color: rgba(100, 115, 130, 0.5);
}

body.fiat-view .toggle-switch::after {
  left: 29px;
  background: var(--fiat-steel);
  box-shadow: 0 0 10px rgba(100, 115, 130, 0.4);
}

/* ─── TREE VIEWS ─── */
.tree-view {
  display: none;
  justify-content: center;
  padding: 10px 12px 60px;
  opacity: 0;
  transition: opacity 0.4s ease;
}

.tree-view.active {
  display: flex;
  opacity: 1;
}

.tree-container {
  width: 100%;
  max-width: 800px;
  text-align: center;
}

.tree-title {
  font-size: clamp(1.4rem, 6vw, 2.2rem);
  font-weight: 600;
  letter-spacing: 0.08em;
  margin-bottom: 4px;
  text-transform: uppercase;
}

.tree-title.btc { color: var(--btc-orange); }
.tree-title.fiat { color: #8a9298; }

.tree-subtitle {
  font-style: italic;
  font-weight: 400;
  font-size: clamp(0.9rem, 3vw, 1.1rem);
  margin-bottom: 12px;
  color: #a09890;
}

body.fiat-view .tree-subtitle {
  color: #8090a0;
}

.tree-svg {
  width: 100%;
  max-width: 800px;
  height: auto;
}

/* ─── TREE ELEMENTS ─── */
.trunk { stroke-linecap: round; }
.trunk.btc { stroke: var(--btc-bark); }
.trunk.fiat { stroke: var(--fiat-bark); }

.branch { stroke-linecap: round; }
.branch.btc { stroke: var(--btc-bark-light); }
.branch.fiat { stroke: var(--fiat-slate); }

.twig { stroke-linecap: round; opacity: 0.5; }
.twig.btc { stroke: var(--btc-bark-light); }
.twig.fiat { stroke: var(--fiat-slate); }

.root { stroke-linecap: round; opacity: 0.35; }
.root.btc { stroke: var(--btc-bark); }
.root.fiat { stroke: var(--fiat-bark); }

/* ─── CLUSTER LABELS ─── */
.cluster-label {
  font-family: var(--font-ui);
  font-weight: 700;
  letter-spacing: 0.12em;
  text-transform: uppercase;
}

.cluster-label.btc { fill: #ffd080; }
.cluster-label.fiat { fill: #b0c0d0; }

.label-bg {
  fill: rgba(0,0,0,0.85);
  rx: 6;
  ry: 6;
}

/* ─── LEAF ELLIPSES ─── */
.leaf { cursor: pointer; }
.leaf:hover .leaf-ellipse {
  filter: drop-shadow(0 6px 20px rgba(0,0,0,0.7)) brightness(1.1);
}

.leaf-ellipse {
  transition: all 0.2s ease;
  filter: drop-shadow(0 3px 8px rgba(0,0,0,0.5));
}

.leaf-ellipse.btc { fill: #f7931a; }
.leaf-ellipse.btc-alt { fill: #ffb030; }
.leaf-ellipse.fiat { fill: #5a6672; }
.leaf-ellipse.fiat-alt { fill: #6a4a4a; }

/* ─── LEAF TEXT ─── */
.leaf-text {
  font-family: var(--font-ui);
  font-weight: 700;
  pointer-events: none;
  text-anchor: middle;
  dominant-baseline: central;
}

.leaf-text.btc {
  fill: #1a0d00;
}

.leaf-text.fiat {
  fill: #ffffff;
  filter: drop-shadow(0 1px 2px rgba(0,0,0,0.5));
}

/* ─── TOOLTIP ─── */
.tooltip {
  position: fixed;
  max-width: 340px;
  padding: 18px 20px;
  border-radius: 12px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.15s ease;
  z-index: 1000;
  line-height: 1.6;
}
.tooltip.visible { opacity: 1; }

.tooltip.btc-tip {
  background: linear-gradient(135deg, rgba(40,32,20,0.98), rgba(30,24,14,0.98));
  border: 2px solid rgba(247,147,26,0.6);
  box-shadow: 0 16px 48px rgba(0,0,0,0.75), 0 0 40px rgba(247,147,26,0.12);
}

.tooltip.fiat-tip {
  background: linear-gradient(135deg, rgba(26,30,38,0.98), rgba(18,20,26,0.98));
  border: 2px solid rgba(120,135,155,0.5);
  box-shadow: 0 16px 48px rgba(0,0,0,0.75);
}

.tooltip-word {
  font-family: var(--font-display);
  font-size: 1.4rem;
  font-weight: 600;
  margin-bottom: 10px;
  letter-spacing: 0.03em;
}
.tooltip-word.btc { color: #ffaa33; }
.tooltip-word.fiat { color: #b8c4d0; }

.tooltip-desc {
  font-family: var(--font-display);
  font-size: 1.1rem;
  font-weight: 400;
  color: #d8d0c8;
  line-height: 1.65;
}

body.fiat-view .tooltip-desc {
  color: #c8d0d8;
}

.tooltip-syn {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid rgba(255,255,255,0.15);
  font-family: var(--font-ui);
  font-size: 0.85rem;
  font-weight: 500;
  color: #999;
}
.tooltip-syn span { margin: 0 5px; }

/* ─── FOOTER ─── */
footer {
  text-align: center;
  padding: 24px 16px 40px;
  font-size: 0.9rem;
}
footer a { 
  color: var(--btc-orange); 
  text-decoration: none;
  font-weight: 500;
}
footer a:hover { text-decoration: underline; }

body.fiat-view footer a {
  color: #8a9aa8;
}

/* ─── MOBILE: Larger leaves and text ─── */
@media (max-width: 600px) {
  header { padding: 16px 12px 6px; top: 0; }
  header h1 { font-size: 1.1rem; letter-spacing: 0.06em; }
  header p { font-size: 0.8rem; }
  
  .toggle-container { 
    padding: 10px 12px; 
    gap: 10px; 
    top: 50px; 
  }
  .toggle-label { 
    padding: 8px 12px; 
    font-size: 0.8rem; 
  }
  
  .tree-view { padding: 8px 8px 40px; }
  .tree-title { font-size: 1.3rem; }
  .tree-subtitle { font-size: 0.85rem; margin-bottom: 8px; }
  
  .tooltip { 
    max-width: calc(100vw - 32px); 
    padding: 14px 16px;
    left: 16px !important;
    right: 16px;
    width: auto;
  }
  .tooltip-word { font-size: 1.2rem; }
  .tooltip-desc { font-size: 1rem; }
}
</style>
</head>
<body class="btc-view">

<header>
  <h1>The Money Trees</h1>
  <p>Tap each leaf to explore the nature of money</p>
</header>

<div class="toggle-container">
  <span class="toggle-label btc active" onclick="showTree('btc')">Bitcoin</span>
  <div class="toggle-switch" onclick="toggleTree()"></div>
  <span class="toggle-label fiat" onclick="showTree('fiat')">Fiat</span>
</div>

<div id="btc-view" class="tree-view active">
  <div class="tree-container">
    <h2 class="tree-title btc">Bitcoin</h2>
    <p class="tree-subtitle">Sound money · Sovereignty · Truth</p>
    <svg id="btc-tree" class="tree-svg"></svg>
  </div>
</div>

<div id="fiat-view" class="tree-view">
  <div class="tree-container">
    <h2 class="tree-title fiat">Fiat</h2>
    <p class="tree-subtitle">Broken money · Coercion · Decay</p>
    <svg id="fiat-tree" class="tree-svg"></svg>
  </div>
</div>

<div id="tooltip" class="tooltip">
  <div id="tip-word" class="tooltip-word"></div>
  <div id="tip-desc" class="tooltip-desc"></div>
  <div id="tip-syn" class="tooltip-syn"></div>
</div>

<footer>
  <a href="https://lastcoinstanding.com">lastcoinstanding.com</a>
</footer>

<script>
// ═══════════════════════════════════════════════════════════
// RESPONSIVE DETECTION
// ═══════════════════════════════════════════════════════════
function isMobile() {
  return window.innerWidth <= 600;
}

// ═══════════════════════════════════════════════════════════
// TOGGLE FUNCTIONALITY
// ═══════════════════════════════════════════════════════════
let currentView = 'btc';

function showTree(view) {
  currentView = view;
  document.body.className = view + '-view';
  
  document.getElementById('btc-view').classList.toggle('active', view === 'btc');
  document.getElementById('fiat-view').classList.toggle('active', view === 'fiat');
  
  document.querySelector('.toggle-label.btc').classList.toggle('active', view === 'btc');
  document.querySelector('.toggle-label.fiat').classList.toggle('active', view === 'fiat');
  
  hideTooltip();
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

function toggleTree() {
  showTree(currentView === 'btc' ? 'fiat' : 'btc');
}

// ═══════════════════════════════════════════════════════════
// WORD DATA - BITCOIN
// ═══════════════════════════════════════════════════════════
const btcClusters = [
  {
    name: "Sovereignty",
    words: [
      { w: "Freedom", desc: "The ability to transact without permission from any authority. Bitcoin restores financial self-determination.", syn: ["Liberty", "Autonomy"] },
      { w: "Self-custody", desc: "You hold your own keys, your own wealth. No intermediary can freeze, seize, or deny access.", syn: ["Control", "Ownership"] },
      { w: "Autonomy", desc: "Independence from institutional gatekeepers. Your money answers only to you.", syn: ["Independence"] },
      { w: "Permissionless", desc: "No application required. No approval needed. Anyone can participate in the network.", syn: ["Open", "Accessible"] },
      { w: "Sovereign", desc: "Each holder is their own bank, their own central authority over their wealth.", syn: ["Self-ruling"] }
    ]
  },
  {
    name: "Integrity",
    words: [
      { w: "Truth", desc: "An immutable ledger that cannot lie. Every transaction is verifiable, transparent, and permanent.", syn: ["Honesty", "Veracity"] },
      { w: "Incorruptible", desc: "No entity can alter the rules, manipulate supply, or corrupt the protocol for personal gain.", syn: ["Pure", "Untainted"] },
      { w: "Transparent", desc: "Open-source code and a public ledger. Anyone can audit, verify, and trust through verification.", syn: ["Open", "Visible"] },
      { w: "Immutable", desc: "What is written cannot be erased. The ledger is permanent and tamper-proof.", syn: ["Permanent", "Fixed"] },
      { w: "Trustless", desc: "No need to trust any party. The protocol enforces rules through mathematics, not promises.", syn: ["Verifiable"] }
    ]
  },
  {
    name: "Scarcity",
    words: [
      { w: "21 Million", desc: "The absolute, unalterable cap. No more can ever exist. Digital scarcity perfected.", syn: ["Fixed supply", "Hard cap"] },
      { w: "Finite", desc: "Unlike fiat which can be printed infinitely, Bitcoin has mathematical limits baked into its code.", syn: ["Limited", "Bounded"] },
      { w: "Sound", desc: "Money that cannot be debased or diluted. Its purchasing power is protected by code.", syn: ["Hard", "Reliable"] },
      { w: "Pristine", desc: "Collateral with no counterparty risk. An asset that is no one's liability.", syn: ["Pure", "Clean"] },
      { w: "Deflationary", desc: "As adoption grows against fixed supply, each unit represents more of the world's value.", syn: ["Appreciating"] }
    ]
  },
  {
    name: "Resilience",
    words: [
      { w: "Antifragile", desc: "Attacks make it stronger. Each challenge overcome proves and improves the network.", syn: ["Robust", "Hardened"] },
      { w: "Decentralized", desc: "No single point of failure. Thousands of nodes across the globe ensure survival.", syn: ["Distributed"] },
      { w: "Unstoppable", desc: "No government, corporation, or individual can stop a valid transaction.", syn: ["Censorship-resistant"] },
      { w: "Persistent", desc: "Running continuously since 2009. The network has never been successfully attacked or shut down.", syn: ["Enduring"] }
    ]
  },
  {
    name: "Nature",
    words: [
      { w: "Organic", desc: "Emerged spontaneously without central planning. Grew through voluntary adoption, not mandate.", syn: ["Natural", "Emergent"] },
      { w: "Meritocratic", desc: "No privileges, no special access. Everyone plays by the same rules enforced by code.", syn: ["Fair", "Equal"] },
      { w: "Voluntary", desc: "Adoption by choice, not coercion. People opt in because they recognize its value.", syn: ["Consensual"] },
      { w: "Elegant", desc: "Simple rules create complex, beautiful order. Satoshi's design is minimalist perfection.", syn: ["Simple", "Beautiful"] }
    ]
  },
  {
    name: "Energy",
    words: [
      { w: "Proof-of-Work", desc: "Real energy expenditure secures the network. Unforgeable costliness creates true value.", syn: ["PoW", "Mining"] },
      { w: "Grounded", desc: "Anchored to physical reality through energy consumption. Not abstract promises but real resources.", syn: ["Rooted", "Real"] },
      { w: "Thermodynamic", desc: "Security backed by the laws of physics. Attacking requires expending real-world energy.", syn: ["Physical"] },
      { w: "Productive", desc: "Mining incentivizes renewable energy development and utilizes stranded power.", syn: ["Efficient"] }
    ]
  },
  {
    name: "Time",
    words: [
      { w: "Lindy", desc: "The longer it survives, the longer it's likely to survive. Each year adds to its life expectancy.", syn: ["Time-tested"] },
      { w: "Patient", desc: "Rewards low time preference. Encourages saving over consumption, planning over impulse.", syn: ["Long-term"] },
      { w: "Generational", desc: "Wealth that can be passed down intact. A store of value for centuries, not just years.", syn: ["Legacy", "Heritage"] },
      { w: "Eternal", desc: "Designed to outlast institutions, governments, and perhaps civilizations.", syn: ["Timeless"] }
    ]
  },
  {
    name: "Virtue",
    words: [
      { w: "Honest", desc: "Cannot lie about supply, cannot hide transactions, cannot pretend to be what it's not.", syn: ["Truthful", "Sincere"] },
      { w: "Courageous", desc: "Challenges the most powerful institutions on Earth. A peaceful revolution in money.", syn: ["Bold", "Brave"] },
      { w: "Humble", desc: "No central authority claims credit. No face on the coin. The protocol serves, not rules.", syn: ["Modest"] },
      { w: "Hopeful", desc: "Offers a path to sound money for all humanity. A tool for human flourishing.", syn: ["Optimistic"] }
    ]
  }
];

// ═══════════════════════════════════════════════════════════
// WORD DATA - FIAT
// ═══════════════════════════════════════════════════════════
const fiatClusters = [
  {
    name: "Coercion",
    words: [
      { w: "Compulsory", desc: "Legal tender laws force acceptance. You have no choice but to use their money.", syn: ["Mandatory", "Forced"] },
      { w: "Permissioned", desc: "Every transaction requires approval. Banks, governments, and payment processors are gatekeepers.", syn: ["Controlled"] },
      { w: "Censored", desc: "Accounts frozen, transactions blocked, access denied. Your money is only yours if they allow it.", syn: ["Blocked", "Silenced"] },
      { w: "Surveilled", desc: "Every transaction tracked, recorded, analyzed. Financial privacy is extinct.", syn: ["Monitored"] },
      { w: "Confiscated", desc: "Bail-ins, asset freezes, civil forfeiture. They can take what they claim is yours.", syn: ["Seized", "Stolen"] }
    ]
  },
  {
    name: "Dishonesty",
    words: [
      { w: "Opaque", desc: "Central bank decisions made in closed rooms. The true money supply is unknowable.", syn: ["Hidden", "Secret"] },
      { w: "Manipulated", desc: "Interest rates, money supply, exchange rates—all artificially controlled.", syn: ["Rigged", "Distorted"] },
      { w: "Fabricated", desc: "Created from nothing with a keystroke. No backing, no constraint, no substance.", syn: ["Invented"] },
      { w: "Deceptive", desc: "Inflation is called 'stimulus.' Money printing is 'quantitative easing.' Lies wrapped in jargon.", syn: ["Misleading"] },
      { w: "Fraudulent", desc: "Fractional reserve banking creates money that doesn't exist. A system built on accounting fiction.", syn: ["Counterfeit"] }
    ]
  },
  {
    name: "Theft",
    words: [
      { w: "Inflation", desc: "The silent tax that steals purchasing power while you sleep. Your savings evaporate.", syn: ["Debasement"] },
      { w: "Cantillon", desc: "Those closest to the money printer benefit first. Everyone else pays through rising prices.", syn: ["Inequality"] },
      { w: "Seigniorage", desc: "The profit governments extract by creating money worth more than its cost to produce.", syn: ["Hidden tax"] },
      { w: "Expropriation", desc: "Bail-ins turn depositors into unwilling bank investors. Your money becomes their capital.", syn: ["Seizure"] }
    ]
  },
  {
    name: "Fragility",
    words: [
      { w: "Centralized", desc: "Single points of failure everywhere. One decision, one hack, one policy can collapse it all.", syn: ["Concentrated"] },
      { w: "Fragile", desc: "Requires constant intervention to prevent collapse. Held together by faith and force.", syn: ["Brittle", "Weak"] },
      { w: "Dependent", desc: "Relies on trusted third parties at every step. Trust that is regularly betrayed.", syn: ["Vulnerable"] },
      { w: "Corruptible", desc: "Human administrators can be bribed, threatened, or simply make mistakes.", syn: ["Exploitable"] },
      { w: "Unstable", desc: "Boom and bust cycles engineered by monetary policy. Volatility by design.", syn: ["Chaotic"] }
    ]
  },
  {
    name: "Decay",
    words: [
      { w: "Debasement", desc: "Every unit becomes worth less over time. Designed to lose value. Guaranteed to fail.", syn: ["Erosion", "Dilution"] },
      { w: "Ephemeral", desc: "Average fiat currency lifespan: 27 years. All eventually go to zero.", syn: ["Temporary"] },
      { w: "Terminal", desc: "The mathematical endpoint of compound inflation is always hyperinflation or collapse.", syn: ["Dying", "Doomed"] },
      { w: "Unsalvageable", desc: "Too much debt, too much printing. The system cannot be reformed, only replaced.", syn: ["Irreparable"] }
    ]
  },
  {
    name: "Artifice",
    words: [
      { w: "Contrived", desc: "Designed by committees, imposed by decree. Nothing natural about it.", syn: ["Artificial"] },
      { w: "Arbitrary", desc: "Rules change on political whims. What's allowed today may be forbidden tomorrow.", syn: ["Capricious"] },
      { w: "Abstract", desc: "Disconnected from physical reality. Numbers on screens backed by nothing but promises.", syn: ["Unreal", "Virtual"] },
      { w: "Bureaucratic", desc: "Layers of administration extract value and add friction. Paper-pushers everywhere.", syn: ["Administrative"] }
    ]
  }
];

// ═══════════════════════════════════════════════════════════
// GLOBAL LEAF REGISTRY
// ═══════════════════════════════════════════════════════════
let allLeaves = [];

// ═══════════════════════════════════════════════════════════
// MEASURE TEXT WIDTH
// ═══════════════════════════════════════════════════════════
function measureTextWidth(text, fontSize) {
  const narrow = 'iltfjr';
  const wide = 'mwMW';
  let width = 0;
  for (const char of text) {
    if (narrow.includes(char)) width += fontSize * 0.4;
    else if (wide.includes(char)) width += fontSize * 0.8;
    else if (char === char.toUpperCase() && char !== char.toLowerCase()) width += fontSize * 0.7;
    else width += fontSize * 0.58;
  }
  return width;
}

// ═══════════════════════════════════════════════════════════
// LAYOUT ENGINE - Clear separation between labels and leaves
// ═══════════════════════════════════════════════════════════
function layoutTree(clusters, side) {
  const mobile = isMobile();
  
  // Dimensions - extra tall on mobile for proper spacing
  const W = mobile ? 400 : 800;
  const H = mobile ? 2000 : 1600;  // Even taller on mobile
  const fontSize = mobile ? 11 : 14;
  const labelFontSize = mobile ? 11 : 14;
  const baseRy = mobile ? 20 : 26;  // Slightly smaller leaves on mobile
  const minGap = mobile ? 12 : 18;
  const cols = mobile ? 2 : 3;
  
  const trunkX = W / 2;
  const trunkBase = H - 50;
  const trunkTop = mobile ? 50 : 80;
  
  const leaves = [];
  const branches = [];
  const twigs = [];
  const roots = [];
  const labels = [];
  
  const placedShapes = [];
  
  const numClusters = clusters.length;
  // More space per cluster
  const clusterHeight = (trunkBase - trunkTop - (mobile ? 100 : 200)) / numClusters;
  
  clusters.forEach((cluster, ci) => {
    const nWords = cluster.words.length;
    const branchY = trunkTop + (mobile ? 80 : 120) + ci * clusterHeight;
    
    const goLeft = ci % 2 === 0;
    const direction = goLeft ? -1 : 1;
    
    const branchLen = mobile ? 40 : 100;
    const branchAngle = direction * (25 + (ci % 3) * 3);
    const branchRad = branchAngle * Math.PI / 180;
    
    const bEndX = trunkX + Math.sin(branchRad) * branchLen;
    const bEndY = branchY - Math.abs(Math.cos(branchRad)) * branchLen * 0.15;
    
    branches.push({ x1: trunkX, y1: branchY, x2: bEndX, y2: bEndY, side });
    
    // ═══════════════════════════════════════════════════════
    // LABEL: Positioned at the branch tip, ABOVE the branch
    // ═══════════════════════════════════════════════════════
    const labelX = bEndX;
    const labelY = bEndY - (mobile ? 18 : 22);  // Above the branch end
    
    labels.push({
      x: labelX,
      y: labelY,
      text: cluster.name,
      side,
      anchor: 'middle',
      fontSize: labelFontSize
    });
    
    // ═══════════════════════════════════════════════════════
    // LEAVES: Start well BELOW the label with guaranteed gap
    // ═══════════════════════════════════════════════════════
    const paddingX = mobile ? 14 : 24;
    // Key fix: leaves start much further below the branch/label
    const labelBottomY = labelY + labelFontSize + 8;  // Bottom of label
    const leafStartY = labelBottomY + (mobile ? 55 : 70);  // Big gap below label
    
    cluster.words.forEach((word, wi) => {
      const textWidth = measureTextWidth(word.w, fontSize);
      const rx = Math.max(mobile ? 36 : 50, (textWidth / 2) + paddingX);
      const ry = baseRy;
      
      const row = Math.floor(wi / cols);
      const col = wi % cols;
      const colsInRow = Math.min(cols, nWords - row * cols);
      
      const cellWidth = (rx * 2) + minGap + (mobile ? 8 : 20);
      const cellHeight = ry * 2 + minGap + (mobile ? 14 : 18);
      
      // Center the leaf cluster under the branch
      const clusterCenterX = bEndX + direction * (mobile ? 10 : 40);
      const rowStartX = clusterCenterX - ((colsInRow - 1) * cellWidth) / 2;
      
      let lx = rowStartX + col * cellWidth;
      let ly = leafStartY + row * cellHeight;
      
      // Stagger alternate rows slightly
      if (row % 2 === 1) {
        lx += direction * (mobile ? 8 : 20);
      }
      
      // Collision detection
      let attempts = 0;
      let hasCollision = true;
      
      while (hasCollision && attempts < 50) {
        hasCollision = false;
        
        for (const placed of placedShapes) {
          const dx = (lx - placed.x) / ((rx + placed.rx) * 0.92);
          const dy = (ly - placed.y) / ((ry + placed.ry) * 0.92);
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 1.05) {
            hasCollision = true;
            const angle = Math.atan2(ly - placed.y, lx - placed.x);
            const push = (1.05 - dist) * 20 + 3;
            lx += Math.cos(angle) * push;
            ly += Math.sin(angle) * push;
            break;
          }
        }
        
        lx = Math.max(rx + 10, Math.min(W - rx - 10, lx));
        ly = Math.max(ry + 10, Math.min(H - ry - 50, ly));
        
        attempts++;
      }
      
      placedShapes.push({ x: lx, y: ly, rx: rx, ry: ry });
      
      twigs.push({
        x1: bEndX,
        y1: bEndY,
        x2: lx,
        y2: ly - ry,
        side
      });
      
      const alt = wi % 2 === 1;
      
      leaves.push({
        x: lx,
        y: ly,
        rx: rx,
        ry: ry,
        word: word.w,
        desc: word.desc,
        syn: word.syn,
        side,
        alt,
        fontSize: fontSize
      });
    });
  });
  
  // Roots
  const rootAngles = [-50, -22, 22, 50];
  rootAngles.forEach((a, i) => {
    const rad = a * Math.PI / 180;
    const len = (mobile ? 30 : 55) + (i % 2) * (mobile ? 12 : 25);
    roots.push({
      x1: trunkX + ((i < 2) ? -5 : 5),
      y1: trunkBase,
      x2: trunkX + Math.sin(rad) * len,
      y2: trunkBase + Math.cos(rad) * len * 0.4,
      side
    });
  });
  
  return { W, H, trunkX, trunkBase, trunkTop, branches, twigs, leaves, roots, labels };
}

// ═══════════════════════════════════════════════════════════
// RENDER TREE
// ═══════════════════════════════════════════════════════════
function renderTree(svgId, clusters, side, startIndex) {
  const svg = document.getElementById(svgId);
  const layout = layoutTree(clusters, side);
  const mobile = isMobile();
  
  // Set viewBox
  svg.setAttribute('viewBox', `0 0 ${layout.W} ${layout.H}`);
  
  let html = '';
  
  // Roots
  layout.roots.forEach(r => {
    const sw = mobile ? 8 : 12;
    html += `<line class="root ${side}" x1="${r.x1}" y1="${r.y1}" x2="${r.x2}" y2="${r.y2}" stroke-width="${sw}"/>`;
  });
  
  // Trunk
  const tx = layout.trunkX;
  const tw = mobile ? 10 : 20;
  html += `<path class="trunk ${side}" d="
    M${tx-tw},${layout.trunkBase} 
    C${tx-tw*0.9},${layout.trunkBase-layout.H*0.25} ${tx-tw*0.5},${layout.trunkBase-layout.H*0.55} ${tx},${layout.trunkTop}
    C${tx+tw*0.5},${layout.trunkBase-layout.H*0.55} ${tx+tw*0.9},${layout.trunkBase-layout.H*0.25} ${tx+tw},${layout.trunkBase}
    Z" fill="${side==='btc'?'#5a4030':'#454550'}"/>`;
  
  // Branches
  layout.branches.forEach(b => {
    const sw = mobile ? 8 : 16;
    html += `<line class="branch ${side}" x1="${b.x1}" y1="${b.y1}" x2="${b.x2}" y2="${b.y2}" stroke-width="${sw}"/>`;
  });
  
  // Twigs
  layout.twigs.forEach(t => {
    html += `<line class="twig ${side}" x1="${t.x1}" y1="${t.y1}" x2="${t.x2}" y2="${t.y2}" stroke-width="2"/>`;
  });
  
  // Leaves (rendered before labels so labels appear on top)
  layout.leaves.forEach((leaf) => {
    const ellipseClass = leaf.alt ? `${leaf.side}-alt` : leaf.side;
    const globalIdx = startIndex + allLeaves.length;
    allLeaves.push(leaf);
    
    html += `
      <g class="leaf"
         ontouchstart="showTooltip(event, ${globalIdx})"
         ontouchend="hideTooltipDelayed()"
         onmouseenter="showTooltip(event, ${globalIdx})"
         onmouseleave="hideTooltip()"
         onmousemove="moveTooltip(event)">
        <ellipse class="leaf-ellipse ${ellipseClass}" cx="${leaf.x}" cy="${leaf.y}" rx="${leaf.rx}" ry="${leaf.ry}"/>
        <text class="leaf-text ${leaf.side}" x="${leaf.x}" y="${leaf.y}" font-size="${leaf.fontSize}">${leaf.word}</text>
      </g>`;
  });
  
  // Labels (rendered last so they appear on top of everything)
  layout.labels.forEach(l => {
    const textWidth = l.text.length * (l.fontSize * 0.72) + 18;
    const textHeight = l.fontSize + 10;
    html += `<rect class="label-bg" x="${l.x - textWidth/2}" y="${l.y - textHeight/2}" width="${textWidth}" height="${textHeight}"/>`;
    html += `<text class="cluster-label ${side}" x="${l.x}" y="${l.y + 1}" text-anchor="${l.anchor}" dominant-baseline="middle" font-size="${l.fontSize}">${l.text}</text>`;
  });
  
  svg.innerHTML = html;
  
  return allLeaves.length;
}

// ═══════════════════════════════════════════════════════════
// TOOLTIP
// ═══════════════════════════════════════════════════════════
const tooltip = document.getElementById('tooltip');
const tipWord = document.getElementById('tip-word');
const tipDesc = document.getElementById('tip-desc');
const tipSyn = document.getElementById('tip-syn');
let tooltipTimeout = null;

function showTooltip(e, leafIndex) {
  if (tooltipTimeout) {
    clearTimeout(tooltipTimeout);
    tooltipTimeout = null;
  }
  
  const leaf = allLeaves[leafIndex];
  if (!leaf) return;
  
  tipWord.textContent = leaf.word;
  tipWord.className = 'tooltip-word ' + leaf.side;
  tipDesc.textContent = leaf.desc;
  
  if (leaf.syn && leaf.syn.length) {
    tipSyn.innerHTML = 'Related: ' + leaf.syn.map(s => `<span>${s}</span>`).join(' · ');
    tipSyn.style.display = 'block';
  } else {
    tipSyn.style.display = 'none';
  }
  
  tooltip.className = 'tooltip visible ' + (leaf.side === 'btc' ? 'btc-tip' : 'fiat-tip');
  moveTooltip(e);
}

function moveTooltip(e) {
  const mobile = isMobile();
  
  if (mobile) {
    tooltip.style.left = '16px';
    tooltip.style.right = '16px';
    tooltip.style.bottom = '80px';
    tooltip.style.top = 'auto';
    tooltip.style.width = 'auto';
  } else {
    const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
    const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
    
    let x = clientX + 24;
    let y = clientY - 14;
    
    if (x + 350 > window.innerWidth) x = clientX - 360;
    if (y + 220 > window.innerHeight) y = window.innerHeight - 230;
    if (y < 10) y = 10;
    if (x < 10) x = 10;
    
    tooltip.style.left = x + 'px';
    tooltip.style.top = y + 'px';
    tooltip.style.right = 'auto';
    tooltip.style.bottom = 'auto';
    tooltip.style.width = '';
  }
}

function hideTooltip() {
  tooltip.className = 'tooltip';
}

function hideTooltipDelayed() {
  tooltipTimeout = setTimeout(hideTooltip, 2000);
}

document.addEventListener('touchstart', function(e) {
  if (!e.target.closest('.leaf') && !e.target.closest('.tooltip')) {
    hideTooltip();
  }
});

// ═══════════════════════════════════════════════════════════
// INITIALIZE & HANDLE RESIZE
// ═══════════════════════════════════════════════════════════
function initTrees() {
  allLeaves = [];
  renderTree('btc-tree', btcClusters, 'btc', 0);
  renderTree('fiat-tree', fiatClusters, 'fiat', allLeaves.length);
}

initTrees();

let lastWidth = window.innerWidth;
window.addEventListener('resize', function() {
  const newWidth = window.innerWidth;
  const crossedBreakpoint = (lastWidth <= 600 && newWidth > 600) || (lastWidth > 600 && newWidth <= 600);
  
  if (crossedBreakpoint) {
    lastWidth = newWidth;
    initTrees();
  }
});
</script>
</body>
</html>
